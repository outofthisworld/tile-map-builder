<html lang="en-US">

<head>
    <title>Map builder</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.0.11/handlebars.js"></script>
    <meta charset="UTF-8">
    <meta name="description" content="Online 2D tile map builder">
    <meta name="keywords" content="Online,2D,Tile,Map,Builder,Sprites,Texture,Generator,Free,Javascript">
    <meta name="author" content="Tile map builder">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }
        
        .container {
            width: 100%;
            margin: 0 auto;
        }
        
        .cotainer::before,
        .container::after {
            display: table;
            content: "";
            clear: both;
        }
        
        .container .main_section {
            width: 73%;
            float: left;
            position: relative;
        }
        
        .container .main_section canvas {
            width: 100%;
            height: 100%;
        }
        
        .container .options {
            color: white;
            float: right;
            background: rgb(43, 33, 35);
            width: 20%;
            height: 100%;
        }
        
        #tiles_list {
            list-style-type: none;
            width: 100%;
            overflow: auto;
        }
        
        #tiles_list li {
            display: inline-block;
            width: 20%;
            height: 80px;
            max-height: 80px;
            min-height: 80px;
            margin-top: 10px;
        }
        
        #tiles_list li img {
            display: block;
            margin: 0 auto;
            width: 80%;
            height: 80px;
            max-height: 80px;
            min-height: 80px;
        }
        
        input {
            font-size: 16px;
            display: block;
            margin: 5px auto;
            width: 90%;
            padding: 10px;
            border: none;
        }
        
        input[type="button"] {
            padding: 15px;
            background-color: #3e8e41;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        input[type="number"] {
            width: 50%;
            padding: 5px;
            margin-left: 40%;
        }
        
        small {
            padding-left: 12%;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
        }
        
        .zoom {
            position: absolute;
            top: 20px;
            right: 10px;
            width: 60px;
        }
        
        #zoom_out {
            right: 75px;
        }
        
        .side_nav {
            text-align: center;
            width: 3%;
            min-width: 50px;
            position: relative;
            float: left;
            background: rgb(43, 33, 35);
            min-height: 100%;
        }
        
        textarea {
            display: block;
            width: 90%;
            margin: 0 auto;
            min-height: 150px;
            max-width: 90%;
            min-width: 80%;
        }
        
        nav {
            width: 100%;
            list-style-type: none;
            background: rgb(43, 33, 35);
            padding: 2px;
        }
        
        .right {
            float: right;
        }
        
        nav li {
            display: inline-block;
            padding: 10px 20px;
            color: rgb(255, 255, 255);
            border-radius: 5px;
            background-color: #3e8e41;
        }
        
        nav li:hover {
            background-color: #2fe736;
            color: white;
            cursor: pointer;
        }
        
        #tool_bar {
            list-style-type: none;
            width: 100%;
            color: black;
            position: relative;
            top: -5px;
        }
        
        #tool_bar li {
            max-width: 100%;
            margin-top: 5px;
        }
        
        #tool_bar li i {
            background: rgb(255, 255, 255);
            padding: 15px;
            border-radius: 2px;
        }
        
        #tool_bar li i:hover {
            background-color: #3e8e41;
            cursor: pointer;
        }
        
        #tool_bar li i.active {
            color: white;
            background-color: #3e8e41;
            border: 1px solid white;
        }
        
        #selectedTexture {
            position: relative;
            width: 80%;
            margin: 0 auto;
            top: 20px;
            min-height: 40px;
            border: 2px solid white;
        }
        
        #settings {
            margin-top: 10px;
            max-width: 100%;
        }
        
        #selected_tile_container {
            min-height: 200px;
            width: 90%;
            margin: 0 auto;
            background: rgb(43, 33, 35);
            overflow: auto;
            border: 2px solid #3e8e41;
        }
        
        #selected_tile_container .tile_texture {
            background-color: #3e8e41;
            width: 100%;
            min-width: 100%;
            min-height: 64px;
            height: 64px;
            max-height: 64px;
            text-align: center;
            line-height: 60px;
        }
        
        #selected_tile_container .tile_texture img {
            height: 100%;
            min-height: 100%;
            float: left;
        }
        
        #selected_tile_container .tile_texture .layer_name {
            margin-left: 2px;
            color: white;
        }
        
        #dialog {
            color: white;
            min-width: 30%;
            min-height: 50%;
            height: 50%;
            width: 30%;
            position: absolute;
            top: 25%;
            left: 30%;
            background: rgb(43, 33, 35);
            display: none;
            box-shadow: 0px 8px 16px 10px rgba(8, 5, 5, 0.2);
        }
        
        #dialog::before,
        #dialog::after {
            content: "";
            display: table;
            clear: both;
        }
        
        #dialog .textures_display {
            width: 55%;
            float: left;
        }
        
        #dialog #dialog_content {
            margin-top: 2%;
            padding: 10px;
        }
        
        #dialog .textures_diplay_side {
            width: 40%;
            max-width: 40%;
            float: right;
        }
        
        #dialog .top_bar {
            text-align: center;
            width: 100%;
            min-width: 100%;
            background: rgb(51, 42, 42);
            padding: 5px 0px;
        }
        
        #dialog #close {
            text-align: center;
            position: absolute;
            min-height: 20px;
            min-width: 20px;
            right: 5px;
            top: 5px;
            color: black;
            background: rgb(245, 245, 243);
        }
        
        .textures_diplay_side input[type="button"] {
            padding: 5px;
        }
        
        nav#appNav .nav_inner {
            display: inline-block;
            margin-left: 57px;
        }
        
        nav#appNav .nav_inner ul.menu {
            display: none;
        }
        
        nav#appNav .nav_inner li:hover ul.menu,
        ul.menu:hover {
            position: absolute;
            display: block;
            height: 200px;
            width: 50px;
        }
        /* Dropdown Button */
        
        .dropbtn {
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            padding: 16px;
            border: none;
            cursor: pointer;
        }
        /* The container <div> - needed to position the dropdown content */
        
        .dropdown {
            position: relative;
            display: inline-block;
        }
        /* Dropdown Content (Hidden by Default) */
        
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            z-index: 1;
        }
        /* Links inside the dropdown */
        
        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }
        /* Change color of dropdown links on hover */
        
        .dropdown-content a:hover {
            background-color: #f1f1f1
        }
        /* Show the dropdown menu on hover */
        
        .dropdown:hover .dropdown-content {
            display: block;
        }
        /* Change the background color of the dropdown button when the dropdown content is shown */
        
        .dropdown:hover .dropbtn {
            background-color: #3e8e41;
        }
    </style>
</head>

<body>
    <div class="container">
        <noscript>
            <div style="border: 3px solid rgb(255, 0, 43); padding: 20px;background: rgb(25, 25, 31);">
                <span style="color:red">It appears you don't have javascript enabled, this tool will not function without it! Sorry.</span>
            </div>
        </noscript>
        <nav id="appNav">
            <div class="nav_inner">
                <div class="dropdown">
                    <button class="dropbtn">File</button>
                    <div class="dropdown-content">
                        <a href="#">New grid</a>
                        <a href="#">Resize grid</a>
                        <a href="#">Settings</a>
                        <a href="#">Save map</a>
                        <a href="#">Load map</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropbtn">Insert</button>
                    <div class="dropdown-content">
                        <a href="#">Background Image</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropbtn">Help</button>
                    <div class="dropdown-content">
                        <a href="#">Help</a>
                    </div>
                </div>
            </div>
            <div class="right">
                <li id="save_map">
                    Save
                </li>
                <li id="load_map">
                    Load
                </li>
            </div>
        </nav>
        <div class="side_nav">
            <ul id="tool_bar">
                <li>
                    <i id="pencil_tool" class="fa fa-pencil-square-o active"></i>
                </li>
                <li>
                    <i id="eraser_tool" class="fa fa-eraser"></i>
                </li>
                <li>
                    <i id="select_tool" class="fa fa-hand-pointer-o"></i>
                </li>
            </ul>

            <img id="selectedTexture" src="https://opengameart.org/sites/default/files/Transparency500.png" />
        </div>
        <div class="main_section">
            <canvas id="map_canvas"></canvas>
            <input type="button" value="+" class="zoom" id="zoom_in" />
            <input type="button" value="-" class="zoom" id="zoom_out" />
        </div>
        <div class="options">
            <small>Selected tile layers:</small>

            <div id="selected_tile_container">
                <!--<div class="tile_texture">
                    <img src="https://ak5.picdn.net/shutterstock/videos/559285/thumb/1.jpg?i10c=img.resize(height:160)"/><span class="layer_name">hello</span>
                </div>-->

            </div>
            <br>
            <small>Map data</small>
            <textarea id="map_data" disabled>
                
            </textarea>
            <input type="button" id="generate_map_data" value="Generate data" />
        </div>
        <div id="dialog_container"></div>

        <!-- Empty dialog, insert into content-->
        <script id="blank_dialog" type="text/x-handlebars-template">
            <div id="dialog">
                <div class="top_bar">{{title}}
                    <div id="close">X</div>
                </div>
                <div id="dialog_content">
                </div>
            </div>
        </script>

        <!-- Textures dialog -->
        <script id="textures_dialog" type="text/x-handlebars-template">
            <div class="textures_display">
                <h5>Select texture:</h5>
                <hr><br>
                <ul id="tiles_list">

                </ul>
            </div>
            <div class="textures_diplay_side">
                <input id="image" type="file" accept="image/*" />
                <input type="button" value="Add tile sprite" id="add_tile_image" />
                <input type="button" value="Add tile map" id="add_tile_map" />
            </div>
        </script>

        <!-- New grid dialog -->
        <script id="new_grid_dialog" type="text/x-handlebars-template">

        </script>
    </div>
    <script>
        const map_canvas = document.getElementById('map_canvas'),
            ctx = map_canvas.getContext('2d');
        map_canvas.width = 800;
        map_canvas.height = 1000;

        let map = [],
            tWidth = 0,
            tHeight = 0,
            mapOffsetX = 0,
            mapOffsetY = 0,
            scale = 1,
            selectedTexture = null,
            mouseDownEvent = null,
            selectedTool = 'pencil_tool',
            currentTextureID = 0,
            toPanX = 0,
            toPanY = 0,
            fc = 0,
            selectedTile = null;

        function set_cursor(text) {
            var canvas = document.createElement("canvas");
            canvas.width = 24;
            canvas.height = 24;
            var ctx = canvas.getContext("2d");
            ctx.fillStyle = "#000000";
            ctx.font = "24px FontAwesome";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 12, 12);
            var dataURL = canvas.toDataURL('image/png')
            map_canvas.style.cursor = `url(${dataURL}),auto`;
        }

        function showDialog(contentTemplateId, input) {
            const source = document.getElementById("blank_dialog").innerHTML;
            const template = Handlebars.compile(source);
            const out = template(input);
            document.getElementById('dialog_container').innerHTML = out;
            const content = document.getElementById('dialog_content');
        }


        const toolBarIcons = document.querySelectorAll('#tool_bar li i');
        for (let i = 0; i < toolBarIcons.length; i++) {
            toolBarIcons[i].onclick = function(event) {
                toolBarIcons.forEach(function(icon) {
                    icon.classList.remove('active');
                })
                this.classList.add('active');
                selectedTool = this.id;
            }
        }

        // set_cursor('\uf040');

        document.getElementById('close').onclick = function() {
            dialog.style.display = 'none';
        };

        document.getElementById('selectedTexture').onclick = function() {
            dialog.style.display = 'block';
        }


        document.getElementById('dialog').addEventListener('mousedown', mouseDown, false);

        window.addEventListener('mouseup', mouseUp, false);

        map_canvas.addEventListener('click', function() {
            dialog.style.display = 'none';
        })

        function mouseUp() {
            window.removeEventListener('mousemove', divMove, true);
        }

        function mouseDown(e) {
            window.addEventListener('mousemove', divMove, true);
        }

        function divMove(e) {
            var div = document.getElementById('dialog');
            div.style.position = 'absolute';
            div.style.top = e.clientY + 'px';
            div.style.left = e.clientX + 'px';
        }

        function zoom_in(event) {
            scale += 0.1;
        }

        function zoom_out(event) {
            scale -= 0.1;
        }

        function handle_canvas_mouse_down(event) {
            mouseDownEvent = event;
        }

        function handle_canvas_mouse_up(event) {
            mouseDownEvent = null;
        }

        function handle_canvas_mouse_move(event) {
            const rect = map_canvas.getBoundingClientRect();

            const cX = event.clientX - rect.left;
            const cY = event.clientY - rect.top;

            const boundingRectWidth = rect.right - rect.left;
            const boundingRectHeight = rect.bottom - rect.top;

            const ratioX = map_canvas.width / boundingRectWidth;
            const ratioY = map_canvas.height / boundingRectHeight;

            const canvasX = cX * ratioX;
            const canvasY = cY * ratioY;

            if (!map.length && mouseDownEvent) {
                alert('Please generate a map before attempting to use the canvas area.');
                mouseDownEvent = null;
            } else if (map.length && canvasX >= Math.abs(mapOffsetX) && canvasX <= (map.length * tWidth * scale) -
                mapOffsetX &&
                canvasY >= Math.abs(mapOffsetY) && canvasY < (map[0].length * tHeight * scale) - mapOffsetY) {

                //Coordinates for the selected grid tile
                const aX = Math.floor((canvasX + mapOffsetX) / (64 * scale));
                const aY = Math.floor((canvasY + mapOffsetY) / (64 * scale));

                switch (selectedTool) {
                    case 'pencil_tool':
                        set_cursor('\uf040');
                        if (!mouseDownEvent) {
                            return;
                        }
                        if (!selectedTexture) {
                            alert('A texture must be selected before drawing a tile');
                            mouseDownEvent = null;
                            return;
                        }
                        if (map[aX][aY]) {
                            if (!Array.isArray(map[aX][aY])) {
                                const current = map[aX][aY];
                                if (selectedTexture.id == current.id) return;
                                map[aX][aY] = [current, selectedTexture];
                            } else {
                                const arr = map[aX][aY];
                                const last = arr[arr.length - 1];
                                if (last.id == selectedTexture.id) return;
                                arr.push(selectedTexture);
                            }
                        } else {
                            map[aX][aY] = selectedTexture;
                        }
                        break;
                    case 'eraser_tool':
                        set_cursor('\uf12d');
                        if (!mouseDownEvent) {
                            return;
                        }

                        if (map[aX][aY]) {
                            if (!Array.isArray(map[aX][aY])) {
                                map[aX][aY] = 0;
                            } else {
                                const arr = map[aX][aY];
                                arr.pop();
                                if (arr.length === 0) {
                                    map[aX][aY] = 0;
                                }
                            }
                        }

                        mouseDownEvent = null;

                        break;
                    case 'select_tool':
                        set_cursor('\uf25a');

                        if (!mouseDownEvent) {
                            return;
                        }

                        const selectedTileContainer = document.getElementById('selected_tile_container');
                        const selected = map[aX][aY];
                        selectedTile = {
                            x: aX,
                            y: aY
                        };

                        if (!selected) {
                            selectedTileContainer.innerHTML = "";
                            console.log('setting inner html to nothing')
                            return;
                        }

                        selectedTileContainer.innerHTML = "";

                        const asArray = Array.isArray(selected) ? selected : [selected];

                        asArray.forEach(function(tile) {
                            const div = document.createElement('div');
                            div.classList.add('tile_texture');
                            const img = document.createElement('img');
                            img.src = tile.image.src;
                            div.appendChild(img);
                            const span = document.createElement('span');
                            span.textContent = 'ID:' + tile.id;
                            div.appendChild(span);
                            selectedTileContainer.appendChild(div);
                        })
                        break;
                }
            } else {
                delete map_canvas.style.cursor;
                map_canvas.style.cursor = "move, auto";
                if (mouseDownEvent) {
                    const dX = mouseDownEvent.clientX - event.clientX;
                    const dY = mouseDownEvent.clientY - event.clientY;
                    mapOffsetX = dX;
                    mapOffsetY = dY;
                }
            }
        }

        function handle_window_keydown(event) {
            switch (event.keyCode) {
                case 37:
                    toPanX -= 50;
                    break;
                case 38:
                    toPanY -= 50;
                    break;
                case 39:
                    toPanX += 50;
                    break;
                case 40:
                    toPanY += 50;
                    break;
            }
            fc = 0;
        }

        let lt = Date.now();

        function update() {
            requestAnimationFrame(update);
            const ct = Date.now();
            const timePassed = ct - lt;
            const currentFPS = 1000 / timePassed;
            lt = ct;
            if (fc >= currentFPS) {
                toPanX = 0;
                toPanY = 0;
            }
            mapOffsetX += toPanX / currentFPS;
            mapOffsetY += toPanY / currentFPS;
            fc++;
            ctx.clearRect(0, 0, map_canvas.width, map_canvas.height);
            // ctx.fillStyle = document.getElementById('canvas_fill').value || '#F3F3F3';
            ctx.fillRect(0, 0, map_canvas.width, map_canvas.height);
            for (let i = 0; i < map.length; i++) {
                for (let j = 0; j < map[i].length; j++) {
                    ctx.strokeStyle = document.getElementById('grid_color').value || 'orange';

                    if (!map[i][j]) {
                        ctx.strokeRect((i * tWidth * scale) - mapOffsetX, (j * tHeight * scale) - mapOffsetY,
                            tWidth * scale, tHeight * scale);
                    } else {
                        const arr = !Array.isArray(map[i][j]) ? [map[i][j]] : map[i][j];
                        for (let k = 0; k < arr.length; k++) {
                            if (arr[k].image) {
                                ctx.drawImage(arr[k].image, (i * tWidth * scale) - mapOffsetX, (j * tHeight * scale) -
                                    mapOffsetY, tWidth * scale, tHeight * scale)
                            }
                        }
                    }

                    if (selectedTile && selectedTile.x == i && selectedTile.y == j) {
                        ctx.strokeStyle = 'red';
                        ctx.strokeRect((i * tWidth * scale) - mapOffsetX, (j * tHeight * scale) - mapOffsetY,
                            tWidth * scale, tHeight * scale);
                    }
                }
            }
        }

        function read_image_url(event) {
            var reader = new FileReader();
            reader.onload = function() {
                document.getElementById('add_tile_image').setAttribute('data-file-target', reader.result);
            };

            if (event.target.files[0] && event.target.files[0] instanceof Blob)
                reader.readAsDataURL(event.target.files[0])
        }

        function generate_map(event) {
            const tilesX = document.getElementById('map_size_tiles_x').value;
            const tilesY = document.getElementById('map_size_tiles_y').value;
            const tileWidth = document.getElementById('tile_width').value;
            const tileHeight = document.getElementById('tile_height').value;

            const errors = [];
            if (isNaN(tilesX) || parseInt(tilesX) <= 0) {
                errors[errors.length] = 'Map x tiles must be above 0';
            }
            if (isNaN(tilesY) || parseInt(tilesY) <= 0) {
                errors[errors.length] = 'Map y tiles must be above 0';
            }
            if (isNaN(tileWidth) || parseInt(tileWidth) <= 0) {
                errors[errors.length] = 'tile width must be above 0';
            }
            if (isNaN(tileHeight) || parseInt(tileHeight) <= 0) {
                errors[errors.length] = 'tile height must be above 0';
            }

            if (errors.length > 0) {
                alert(errors.join(':'));
                return;
            }

            const newmap = []

            for (let i = 0; i < tilesX; i++) {
                newmap[i] = newmap[i] || [];
                for (let j = 0; j < tilesY; j++) {
                    newmap[i][j] = 0;
                }
            }

            for (let i = 0; i < map.length; i++) {
                if (i >= newmap.length) break;
                for (let j = 0; j < map[i].length; j++) {
                    if (j >= newmap[i].length) break;
                    newmap[i][j] = map[i][j];
                }
            }

            tWidth = tileWidth;
            tHeight = tileHeight;
            map = newmap;
        }

        function add_tile_map(event) {
            if (!document.getElementById('add_tile_image').hasAttribute('data-file-target')) {
                alert('Please select a file')
                return;
            }
            const url = document.getElementById('add_tile_image').getAttribute('data-file-target');
            const tsX = 64;
            const tsY = 64;
            const image = document.createElement('img');


            image.onload = function() {

                const tile_map_width = image.width;
                const tile_map_height = image.height;
                const numTilesX = tile_map_width / tsX;
                const numTilesY = tile_map_height / tsY;

                if (numTilesX % 1 > 0 || numTilesY % 1 > 0) {
                    alert('Tile map width & height constraints do not match the input tile image width/height');
                    return;
                }

                const canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d');
                canvas.width = tsX;
                canvas.height = tsY;

                console.log(tile_map_width);
                console.log(tile_map_height);
                console.log(numTilesX)
                console.log(numTilesY)

                for (let x = 0; x < numTilesX; x++) {
                    for (let y = 0; y < numTilesY; y++) {
                        currentTextureID++;
                        ctx.clearRect(0, 0, tile_map_width, tile_map_height);
                        //console.log('drawing image @ : x ', -x * tsX)
                        //console.log('drawing image @ : y ', -y * tsY)
                        ctx.drawImage(image, (x * tsX) * -1, (y * tsY) * -1, tile_map_width, tile_map_height);
                        var dataURL = canvas.toDataURL('image/png');
                        console.log(dataURL);
                        const li = document.createElement('li');
                        const croppedImage = document.createElement('img');
                        croppedImage.src = dataURL;
                        li.classList.add('li');
                        li.setAttribute('data-id', currentTextureID);
                        croppedImage.setAttribute('data-id', currentTextureID);
                        const textureObj = {
                            id: currentTextureID,
                            image: croppedImage
                        }
                        croppedImage.onclick = function(event) {
                            const eles = document.querySelectorAll('#tiles_list li img');
                            for (let i = 0; i < eles.length; i++) {
                                eles[i].style.border = 'none';
                            }
                            croppedImage.style.border = '2px solid red';
                            selectedTexture = textureObj;
                        }
                        li.appendChild(croppedImage);
                        document.getElementById('tiles_list').appendChild(li);
                    }
                }
                document.getElementById('add_tile_image').removeAttribute('data-file-target');
                document.getElementById('image').value = '';
            }
            image.src = url;
        }

        function add_tile_image(event) {
            if (!document.getElementById('add_tile_image').hasAttribute('data-file-target')) {
                alert('Please select a file')
                return;
            }
            currentTextureID++;
            const url = document.getElementById('add_tile_image').getAttribute('data-file-target');
            const li = document.createElement('li');
            const imgElement = document.createElement('img');
            imgElement.src = url;

            document.getElementById('add_tile_image').removeAttribute('data-file-target');

            //Format list
            li.classList.add('li');
            li.setAttribute('data-id', currentTextureID);
            imgElement.setAttribute('data-id', currentTextureID);
            const textureObj = {
                id: currentTextureID,
                image: imgElement
            }
            imgElement.onclick = function(event) {
                const eles = document.querySelectorAll('#tiles_list li img');
                for (let i = 0; i < eles.length; i++) {
                    eles[i].style.border = 'none';
                }
                imgElement.style.border = '2px solid red';
                selectedTexture = textureObj;
            }
            li.appendChild(imgElement);
            document.getElementById('tiles_list').appendChild(li);

            //Reset
            document.getElementById('image').value = '';
        }

        function save_map(event) {
            const object_to_serialize = {
                tWidth,
                tHeight
            }
            const imgs = {}
            const textures = document.querySelectorAll('#tiles_list li');
            for (let i = 0; i < textures.length; i++) {
                const li = textures[i];
                const id = li.getAttribute('data-id');
                const img = li.children[0];
                imgs[id] = img.src;
            }

            object_to_serialize.map = map;
            object_to_serialize.textures = imgs;
            const serializedObj = JSON.stringify(object_to_serialize);
            var a = document.createElement("a");
            var file = new Blob([serializedObj], {
                type: 'application/json'
            });
            a.href = URL.createObjectURL(file);
            a.download = 'map';
            a.click();
        }


        function load_map(event) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = function(event) {
                const reader = new FileReader();
                reader.onload = function() {
                    parse_map_json(reader.result)
                };
                reader.readAsText(event.target.files[0])
            }
            input.click();
        }


        function generate_map_data() {
            const map_data = document.getElementById('map_data');
            map_data.textContent = "";
            const imgs = {}
            const textures = document.querySelectorAll('#tiles_list li');
            for (let i = 0; i < textures.length; i++) {
                const li = textures[i];
                const id = li.getAttribute('data-id');
                const img = li.children[0];
                imgs[id] = img.src;
            }

            const map_to_json = [];

            for (let i = 0; i < map.length; i++) {
                map_to_json[i] = new Array(map[i].length).fill(0);
                for (let j = 0; j < map[i].length; j++) {
                    if (!map[i][j]) continue;
                    if (Array.isArray(map[i][j])) {
                        map_to_json[i][j] = [];
                        for (let k = 0; k < map[i][j].length; k++) {
                            map_to_json[i][j][k] = map[i][j][k].id;
                        }
                    } else {
                        map_to_json[i][j] = map[i][j].id;
                    }
                }
            }

            map_data.textContent += `const tile_sprites = ${JSON.stringify(imgs)};`
            map_data.textContent += `const map_data = ${JSON.stringify(map_to_json)};`;
        }


        function parse_map_json(json) {

            try {
                json = JSON.parse(json);
            } catch (err) {
                alert('Error loading json file');
                return;
            }

            if (!json.map || !json.textures || json.tWidth == null || isNaN(json.tWidth) || json.tHeight == null ||
                isNaN(json.tHeight)) {
                alert('Invalid json file format');
                return;
            }

            const textures = json.textures;

            for (key in textures) {
                const li = document.createElement('li');
                li.setAttribute('data-id', key);
                const img = document.createElement('img');
                img.src = textures[key];
                img.setAttribute('data-id', key);
                li.appendChild(img);
                img.onclick = function(event) {
                    const eles = document.querySelectorAll('#tiles_list li img');
                    for (let i = 0; i < eles.length; i++) {
                        eles[i].style.border = 'none';
                    }
                    img.style.border = '2px solid red';
                    selectedTexture = {
                        id: key,
                        image: img
                    };
                }
                const tiles_list = document.getElementById('tiles_list');
                tiles_list.appendChild(li);
                textures[key] = img;
                currentTextureID = key;
            }

            const loaded_map = json.map;

            if (!Array.isArray(loaded_map)) {
                alert('Invalid json file format');
                return;
            }


            for (let i = 0; i < loaded_map.length; i++) {
                for (let j = 0; j < loaded_map[i].length; j++) {
                    if (loaded_map[i][j]) {
                        const arr = Array.isArray(loaded_map[i][j]) ? loaded_map[i][j] : [loaded_map[i][j]];
                        for (let k = 0; k < arr.length; k++) {
                            arr[k].image = textures[arr[k].id];
                        }
                    }
                }
            }

            map = loaded_map;
            tWidth = parseInt(json.tWidth);
            tHeight = parseInt(json.tHeight);
        }


        map_canvas.onmousemove = handle_canvas_mouse_move;
        map_canvas.onmouseup = handle_canvas_mouse_up;
        map_canvas.onmousedown = handle_canvas_mouse_down;
        document.getElementById('zoom_out').onclick = zoom_out;
        document.getElementById('zoom_in').onclick = zoom_in;
        window.addEventListener('keydown', handle_window_keydown);
        document.getElementById('image').onchange = read_image_url;
        //document.getElementById('generate_map').onclick = generate_map;
        document.getElementById('add_tile_image').onclick = add_tile_image;
        document.getElementById('add_tile_map').onclick = add_tile_map;
        document.getElementById('load_map').onclick = load_map;
        document.getElementById('save_map').onclick = save_map;
        document.getElementById('generate_map_data').onclick = generate_map_data;
        requestAnimationFrame(update);
    </script>
    <noscript>
            <META HTTP-EQUIV="Refresh" CONTENT="2;URL=error.html">
    </noscript>
</body>

</html>