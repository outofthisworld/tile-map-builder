<html lang="en-US">

<head>
    <title>Map builder</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.0.11/handlebars.js"></script>
    <meta charset="UTF-8">
    <meta name="description" content="Online 2D tile map builder">
    <meta name="keywords" content="Online,2D,Tile,Map,Builder,Sprites,Texture,Generator,Free,Javascript">
    <meta name="author" content="Tile map builder">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }
        
        .container {
            width: 100%;
            margin: 0 auto;
        }
        
        .cotainer::before,
        .container::after {
            display: table;
            content: "";
            clear: both;
        }
        
        .container .main_section {
            width: 73%;
            float: left;
            position: relative;
        }
        
        .container .main_section canvas {
            width: 100%;
            height: 100%;
        }
        
        .container .options {
            color: white;
            float: right;
            background: rgb(43, 33, 35);
            width: 20%;
            height: 100%;
        }
        
        #tiles_list {
            list-style-type: none;
            width: 100%;
            overflow: auto;
        }
        
        #tiles_list li {
            display: inline-block;
            width: 20%;
            height: 80px;
            max-height: 80px;
            min-height: 80px;
            margin-top: 10px;
        }
        
        #tiles_list li img {
            display: block;
            margin: 0 auto;
            width: 80%;
            height: 80px;
            max-height: 80px;
            min-height: 80px;
        }
        
        input {
            font-size: 16px;
            display: block;
            margin: 5px auto;
            width: 90%;
            padding: 10px;
            border: none;
        }
        
        input[type="button"] {
            padding: 15px;
            margin-top: 10px;
            background-color: #3e8e41;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        input[type="number"] {
            padding: 5px;
        }
        
        small {
            padding-left: 20px;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
        }
        
        .zoom {
            position: absolute;
            top: 20px;
            right: 10px;
            width: 60px;
        }
        
        #zoom_out {
            right: 75px;
        }
        
        .side_nav {
            text-align: center;
            width: 3%;
            min-width: 50px;
            position: relative;
            float: left;
            background: rgb(43, 33, 35);
            min-height: 100%;
        }
        
        textarea {
            display: block;
            width: 90%;
            margin: 0 auto;
            min-height: 150px;
            max-width: 90%;
            min-width: 80%;
        }
        
        nav {
            width: 100%;
            list-style-type: none;
            background: rgb(43, 33, 35);
            padding: 2px;
        }
        
        .right {
            float: right;
        }
        
        nav li {
            display: inline-block;
            padding: 10px 20px;
            color: rgb(255, 255, 255);
            border-radius: 5px;
            background-color: #3e8e41;
        }
        
        nav li:hover {
            background-color: #2fe736;
            color: white;
            cursor: pointer;
        }
        
        #tool_bar {
            list-style-type: none;
            width: 100%;
            color: black;
            position: relative;
            top: -5px;
        }
        
        #tool_bar li {
            max-width: 100%;
            margin-top: 5px;
        }
        
        #tool_bar li i {
            background: rgb(255, 255, 255);
            padding: 15px;
            border-radius: 2px;
        }
        
        #tool_bar li i:hover {
            background-color: #3e8e41;
            cursor: pointer;
        }
        
        #tool_bar li i.active {
            color: white;
            background-color: #3e8e41;
            border: 1px solid white;
        }
        
        #selectedTexture {
            position: relative;
            width: 80%;
            margin: 0 auto;
            top: 20px;
            min-height: 40px;
            border: 2px solid white;
        }
        
        #settings {
            margin-top: 10px;
            max-width: 100%;
        }
        
        #selected_tile_container {
            min-height: 200px;
            width: 90%;
            margin: 0 auto;
            background: rgb(43, 33, 35);
            overflow: auto;
            border: 2px solid #3e8e41;
        }
        
        #selected_tile_container .tile_texture {
            background-color: #3e8e41;
            width: 100%;
            min-width: 100%;
            min-height: 64px;
            height: 64px;
            max-height: 64px;
            text-align: center;
            line-height: 60px;
        }
        
        #selected_tile_container .tile_texture img {
            height: 100%;
            min-height: 100%;
            float: left;
        }
        
        #selected_tile_container .tile_texture .layer_name {
            margin-left: 2px;
            color: white;
        }
        
        #dialog {
            color: white;
            min-width: 30%;
            min-height: 50%;
            height: 50%;
            width: 30%;
            position: absolute;
            top: 25%;
            left: 30%;
            background: rgb(43, 33, 35);
            display: none;
            box-shadow: 0px 8px 16px 10px rgba(8, 5, 5, 0.2);
        }
        
        #dialog::before,
        #dialog::after {
            content: "";
            display: table;
            clear: both;
        }
        
        #dialog .textures_display {
            width: 55%;
            float: left;
        }
        
        #dialog #dialog_content {
            position: relative;
            top: 30px;
            padding: 10px;
            width: 80%;
            margin: 0 auto;
        }
        
        #dialog .textures_diplay_side {
            width: 40%;
            max-width: 40%;
            float: right;
        }
        
        #dialog .top_bar {
            text-align: center;
            width: 100%;
            min-width: 100%;
            background: rgb(51, 42, 42);
            padding: 5px 0px;
        }
        
        #dialog #close {
            text-align: center;
            position: absolute;
            min-height: 20px;
            min-width: 20px;
            right: 5px;
            top: 5px;
            color: black;
            background: rgb(245, 245, 243);
        }
        
        .textures_diplay_side input[type="button"] {
            padding: 5px;
        }
        
        nav#appNav .nav_inner {
            display: inline-block;
            margin-left: 57px;
        }
        
        nav#appNav .nav_inner ul.menu {
            display: none;
        }
        
        nav#appNav .nav_inner li:hover ul.menu,
        ul.menu:hover {
            position: absolute;
            display: block;
            height: 200px;
            width: 50px;
        }
        /* Dropdown Button */
        
        .dropbtn {
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            padding: 16px;
            border: none;
            cursor: pointer;
        }
        /* The container <div> - needed to position the dropdown content */
        
        .dropdown {
            position: relative;
            display: inline-block;
        }
        /* Dropdown Content (Hidden by Default) */
        
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            z-index: 1;
        }
        /* Links inside the dropdown */
        
        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }
        /* Change color of dropdown links on hover */
        
        .dropdown-content a:hover {
            background-color: #f1f1f1
        }
        /* Show the dropdown menu on hover */
        
        .dropdown:hover .dropdown-content {
            display: block;
        }
        /* Change the background color of the dropdown button when the dropdown content is shown */
        
        .dropdown:hover .dropbtn {
            background-color: #3e8e41;
        }
        
        label {
            display: inline-block;
            width: 100%;
            position: relative;
            left: 25px;
        }
    </style>
</head>

<body>
    <div class="container">
        <noscript>
            <div style="border: 3px solid rgb(255, 0, 43); padding: 20px;background: rgb(25, 25, 31);">
                <span style="color:red">It appears you don't have javascript enabled, this tool will not function without it! Sorry.</span>
            </div>
        </noscript>
        <nav id="appNav">
            <div class="nav_inner">
                <div class="dropdown">
                    <button class="dropbtn">File</button>
                    <div class="dropdown-content">
                        <a href="#" id="new_grid">New grid</a>
                        <a href="#">Resize grid</a>
                        <a href="#">Settings</a>
                        <a href="#">Save map</a>
                        <a href="#">Load map</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropbtn">Insert</button>
                    <div class="dropdown-content">
                        <a href="#">Background Image</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropbtn">Help</button>
                    <div class="dropdown-content">
                        <a href="#">Help</a>
                    </div>
                </div>
            </div>
            <div class="right">
                <li id="save_map">
                    Save
                </li>
                <li id="load_map">
                    Load
                </li>
            </div>
        </nav>
        <div class="side_nav">
            <ul id="tool_bar">
                <li>
                    <i id="pencil_tool" class="fa fa-pencil-square-o active"></i>
                </li>
                <li>
                    <i id="eraser_tool" class="fa fa-eraser"></i>
                </li>
                <li>
                    <i id="select_tool" class="fa fa-hand-pointer-o"></i>
                </li>
                <li>
                    <i id="multi_select_tool" class=" fa fa-hand-stop-o"></i>
                </li>
            </ul>

            <img id="selectedTexture" src="https://opengameart.org/sites/default/files/Transparency500.png" />
        </div>
        <div class="main_section">
            <canvas id="map_canvas"></canvas>
            <input type="button" value="+" class="zoom" id="zoom_in" />
            <input type="button" value="-" class="zoom" id="zoom_out" />
        </div>
        <div class="options">
            <small>Selected tile layers:</small>
            <div id="selected_tile_container">

            </div>
            <br>
            <small>Map data</small>
            <textarea id="map_data" disabled>
                
            </textarea>
            <input type="button" id="generate_map_data" value="Generate data" />
        </div>
        <div id="dialog_container"></div>

        <!-- Empty dialog, insert into content-->
        <script id="blank_dialog" type="text/x-handlebars-template">
            <div id="dialog">
                <div class="top_bar">{{title}}
                    <div id="close">X</div>
                </div>
                <div id="dialog_content">
                </div>
            </div>
        </script>

        <!-- Textures dialog -->
        <script id="textures_dialog" type="text/x-handlebars-template">
            <div class="textures_display">
                <h5>Select texture:</h5>
                <hr><br>
                <ul id="tiles_list">

                </ul>
            </div>
            <div class="textures_diplay_side">
                <input id="image" type="file" accept="image/*" />
                <input type="button" value="Add tile sprite" id="add_tile_image" />
                <input type="button" value="Add tile map" id="add_tile_map" />
            </div>
        </script>

        <!-- New grid dialog -->
        <script id="new_grid_dialog" type="text/x-handlebars-template">
            <label for="map_size_tiles_x">Number of tiles on x axis:</label>
            <input type="number" min="1" id="map_size_tiles_x" />
            <label for="map_size_tiles_y">Number of tiles on y axis:</label>
            <input type="number" min="1" id="map_size_tiles_y" />
            <label for="tile_width">Tile width (pixels):</label>
            <input type="number" min="1" id="tile_width" />
            <label for="tile_height">Tile height (pixels):</label>
            <input type="number" min="1" id="tile_height" />
            <input type="button" id="create_grid" value="Create grid" />
        </script>

        <script id="tile_layer_template" type="text/x-handlebars-template">
            <div class="tile_texture">
                <img src="https://ak5.picdn.net/shutterstock/videos/559285/thumb/1.jpg?i10c=img.resize(height:160)" /><span class="layer_name">hello</span>
                <i class=" fa fa-trash-o"></i>
            </div>
        </script>
    </div>
    <script>
        const map_canvas = document.getElementById('map_canvas'),
            ctx = map_canvas.getContext('2d');
        map_canvas.width = 800;
        map_canvas.height = 1000;

        let map = [],
            tWidth = 0,
            tHeight = 0,
            mapOffsetX = 0,
            mapOffsetY = 0,
            scale = 1,
            selectedTexture = null,
            mouseDownEvent = null,
            selectedTool = 'pencil_tool',
            currentTextureID = 0,
            toPanX = 0,
            toPanY = 0,
            fc = 0,
            selectedTiles = [],
            mouseDownStarted = false;

        function set_cursor(text) {
            var canvas = document.createElement("canvas");
            canvas.width = 24;
            canvas.height = 24;
            var ctx = canvas.getContext("2d");
            ctx.fillStyle = "#000000";
            ctx.font = "24px FontAwesome";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 12, 12);
            var dataURL = canvas.toDataURL('image/png')
            map_canvas.style.cursor = `url(${dataURL}),auto`;
        }


        function showDialog(contentTemplateId, input) {
            const dialogContainer = document.getElementById('dialog_container');
            dialogContainer.innerHTML = "";
            const source = document.getElementById("blank_dialog").innerHTML;
            const template = Handlebars.compile(source);
            const out = template(input);
            dialogContainer.innerHTML = out;
            const content = document.getElementById('dialog_content');
            const contentTemplate = Handlebars.compile(document.getElementById(contentTemplateId).innerHTML);
            content.innerHTML = contentTemplate(input);
            const dialog = document.getElementById('dialog');
            document.getElementById('close').onclick = function() {
                dialog.style.display = 'none';
            };
            map_canvas.addEventListener('click', function() {
                dialog.style.display = 'none';
            })
            dialog.addEventListener('mousedown', function mouseDown(e) {
                window.addEventListener('mousemove', dragDiv, true);
            }, false);

            window.addEventListener('mouseup', function mouseUp() {
                window.removeEventListener('mousemove', dragDiv, true);
            }, false);

            function dragDiv(e) {
                var div = document.getElementById('dialog');
                div.style.position = 'absolute';
                div.style.top = e.clientY + 'px';
                div.style.left = e.clientX + 'px';
            }
            dialog.style.display = 'block';
        }

        function closeOpenDialog() {
            const dialog = document.getElementById('dialog');
            dialog.style.display = 'none';
        }

        const toolBarIcons = document.querySelectorAll('#tool_bar li i');
        for (let i = 0; i < toolBarIcons.length; i++) {
            toolBarIcons[i].onclick = function(event) {
                toolBarIcons.forEach(function(icon) {
                    icon.classList.remove('active');
                })
                this.classList.add('active');
                selectedTool = this.id;
            }
        }

        set_cursor('\uf040');



        document.getElementById('selectedTexture').onclick = function() {
            showDialog('textures_dialog', {
                title: 'Select or add texture'
            });
            document.getElementById('image').onchange = read_image_url;
            document.getElementById('add_tile_image').onclick = add_tile_image;
            document.getElementById('add_tile_map').onclick = add_tile_map;
        }

        document.getElementById('new_grid').onclick = function() {
            showDialog('new_grid_dialog', {
                title: 'Create new grid'
            });
            document.getElementById('create_grid').onclick = generate_map;
        }

        function zoom_in(event) {
            scale += 0.1;
        }

        function zoom_out(event) {
            scale -= 0.1;
        }

        function handle_canvas_mouse_down(event) {
            mouseDownEvent = event;
        }

        function handle_canvas_mouse_up(event) {
            mouseDownEvent = null;
        }

        function handle_canvas_mouse_move(event) {
            const rect = map_canvas.getBoundingClientRect();

            const cX = event.clientX - rect.left;
            const cY = event.clientY - rect.top;

            const boundingRectWidth = rect.right - rect.left;
            const boundingRectHeight = rect.bottom - rect.top;

            const ratioX = map_canvas.width / boundingRectWidth;
            const ratioY = map_canvas.height / boundingRectHeight;

            const canvasX = cX * ratioX;
            const canvasY = cY * ratioY;

            if (!map.length && mouseDownEvent) {
                alert('Please generate a map before attempting to use the canvas area.');
                mouseDownEvent = null;
            } else if (map.length && canvasX >= Math.abs(mapOffsetX) && canvasX <= (map.length * tWidth * scale) -
                mapOffsetX &&
                canvasY >= Math.abs(mapOffsetY) && canvasY < (map[0].length * tHeight * scale) - mapOffsetY) {

                //Coordinates for the selected grid tile
                const aX = Math.floor((canvasX + mapOffsetX) / (64 * scale));
                const aY = Math.floor((canvasY + mapOffsetY) / (64 * scale));

                switch (selectedTool) {
                    case 'pencil_tool':
                        set_cursor('\uf040');
                        if (!mouseDownEvent) {
                            return;
                        }
                        if (!selectedTexture) {
                            alert('A texture must be selected before drawing a tile');
                            mouseDownEvent = null;
                            return;
                        }
                        if (map[aX][aY]) {
                            if (!Array.isArray(map[aX][aY])) {
                                const current = map[aX][aY];
                                if (selectedTexture.id == current.id) return;
                                map[aX][aY] = [current, selectedTexture];
                            } else {
                                const arr = map[aX][aY];
                                const last = arr[arr.length - 1];
                                if (last.id == selectedTexture.id) return;
                                arr.push(selectedTexture);
                            }
                        } else {
                            map[aX][aY] = selectedTexture;
                        }
                        break;
                    case 'eraser_tool':
                        set_cursor('\uf12d');
                        if (!mouseDownEvent) {
                            return;
                        }

                        if (map[aX][aY]) {
                            if (!Array.isArray(map[aX][aY])) {
                                map[aX][aY] = 0;
                            } else {
                                const arr = map[aX][aY];
                                arr.pop();
                                if (arr.length === 0) {
                                    map[aX][aY] = 0;
                                }
                            }
                        }

                        mouseDownEvent = null;

                        break;
                    case 'select_tool':
                        set_cursor('\uf25a');

                        if (!mouseDownEvent) {
                            return;
                        }

                        const selectedTileContainer = document.getElementById('selected_tile_container');
                        const selected = map[aX][aY];

                        selectedTileContainer.innerHTML = "";

                        if (!selected) {
                            return;
                        }

                        selectedTiles = [{
                            x: aX,
                            y: aY
                        }];

                        const asArray = Array.isArray(selected) ? selected : [selected];

                        asArray.forEach(function(tile) {
                            const div = document.createElement('div');
                            div.classList.add('tile_texture');
                            const img = document.createElement('img');
                            img.src = tile.image.src;
                            div.appendChild(img);
                            const span = document.createElement('span');
                            span.textContent = 'ID:' + tile.id;
                            div.appendChild(span);
                            selectedTileContainer.appendChild(div);
                        })
                        break;
                    case 'multi_select_tool':
                        set_cursor('\uf256');

                        if (!mouseDownEvent) {
                            mouseDownStarted = false;
                            return;
                        }

                        const selectedTileContainerr = document.getElementById('selected_tile_container');
                        const selectedd = map[aX][aY];

                        selectedTileContainerr.innerHTML = "";

                        if (!selectedd) {
                            return;
                        }

                        if (!mouseDownStarted) {
                            selectedTiles = [];
                            mouseDownStarted = !mouseDownStarted;
                        }

                        selectedTiles = selectedTiles || [];
                        selectedTiles[selectedTiles.length] = {
                            x: aX,
                            y: aY
                        }
                        break;
                }
            } else {
                delete map_canvas.style.cursor;
                map_canvas.style.cursor = "move, auto";
                if (mouseDownEvent) {
                    const dX = mouseDownEvent.clientX - event.clientX;
                    const dY = mouseDownEvent.clientY - event.clientY;
                    mapOffsetX = dX;
                    mapOffsetY = dY;
                }
            }
        }

        function handle_window_keydown(event) {
            switch (event.keyCode) {
                case 37:
                    toPanX -= 50;
                    break;
                case 38:
                    toPanY -= 50;
                    break;
                case 39:
                    toPanX += 50;
                    break;
                case 40:
                    toPanY += 50;
                    break;
            }
            fc = 0;
        }

        let lt = Date.now();

        function update() {
            requestAnimationFrame(update);
            const ct = Date.now();
            const timePassed = ct - lt;
            const currentFPS = 1000 / timePassed;
            lt = ct;
            if (fc >= currentFPS) {
                toPanX = 0;
                toPanY = 0;
            }
            mapOffsetX += toPanX / currentFPS;
            mapOffsetY += toPanY / currentFPS;
            fc++;
            ctx.clearRect(0, 0, map_canvas.width, map_canvas.height);
            // document.getElementById('canvas_fill').value || 
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, map_canvas.width, map_canvas.height);
            for (let i = 0; i < map.length; i++) {
                for (let j = 0; j < map[i].length; j++) {
                    // document.getElementById('grid_color').value
                    ctx.strokeStyle = 'orange';

                    if (!map[i][j]) {
                        ctx.strokeRect((i * tWidth * scale) - mapOffsetX, (j * tHeight * scale) - mapOffsetY,
                            tWidth * scale, tHeight * scale);
                    } else {
                        const arr = !Array.isArray(map[i][j]) ? [map[i][j]] : map[i][j];
                        for (let k = 0; k < arr.length; k++) {
                            if (arr[k].image) {
                                ctx.drawImage(arr[k].image, (i * tWidth * scale) - mapOffsetX, (j * tHeight * scale) -
                                    mapOffsetY, tWidth * scale, tHeight * scale)
                            }
                        }
                    }

                    if (selectedTiles) {
                        for (let p = 0; p < selectedTiles.length; p++) {
                            if (selectedTiles[p].x == i && selectedTiles[p].y == j) {
                                ctx.strokeStyle = 'red';
                                ctx.strokeRect((i * tWidth * scale) - mapOffsetX, (j * tHeight * scale) - mapOffsetY,
                                    tWidth * scale, tHeight * scale);
                            }
                        }
                    }
                }
            }
        }

        function read_image_url(event) {
            var reader = new FileReader();
            reader.onload = function() {
                document.getElementById('add_tile_image').setAttribute('data-file-target', reader.result);
            };

            if (event.target.files[0] && event.target.files[0] instanceof Blob)
                reader.readAsDataURL(event.target.files[0])
        }

        function generate_map(event) {
            console.log('generating map')
            const tilesX = document.getElementById('map_size_tiles_x').value;
            const tilesY = document.getElementById('map_size_tiles_y').value;
            const tileWidth = document.getElementById('tile_width').value;
            const tileHeight = document.getElementById('tile_height').value;


            const errors = [];

            if (!tilesX || isNaN(tilesX) || parseInt(tilesX) <= 0) {
                errors[errors.length] = 'Map x tiles must be above 0';
            }
            if (!tilesY || isNaN(tilesY) || parseInt(tilesY) <= 0) {
                errors[errors.length] = 'Map y tiles must be above 0';
            }
            if (!tileWidth || isNaN(tileWidth) || parseInt(tileWidth) <= 0) {
                errors[errors.length] = 'tile width must be above 0';
            }
            if (!tileHeight || isNaN(tileHeight) || parseInt(tileHeight) <= 0) {
                errors[errors.length] = 'tile height must be above 0';
            }
            console.log(errors)

            if (errors.length) {
                console.log('errors')
                alert(errors.join('\n'));
                return;
            }

            const newmap = []

            for (let i = 0; i < tilesX; i++) {
                newmap[i] = newmap[i] || [];
                for (let j = 0; j < tilesY; j++) {
                    newmap[i][j] = 0;
                }
            }

            for (let i = 0; i < map.length; i++) {
                if (i >= newmap.length) break;
                for (let j = 0; j < map[i].length; j++) {
                    if (j >= newmap[i].length) break;
                    newmap[i][j] = map[i][j];
                }
            }

            tWidth = tileWidth;
            tHeight = tileHeight;
            map = newmap;
            tilesX.value = "";
            tilesY.value = "";
            tileWidth.value = "";
            tileHeight.value = "";
            closeOpenDialog();
        }

        function add_tile_map(event) {
            //Display dialog asking for these values
            add_tile_image({
                tsX: 64,
                tsY: 64
            });
        }

        function display_all_textures_in_dom() {
            if (!loadedTextures) return;
            for (let i = 0; i < loadedTextures.length; i++) {
                const texture = loadedTextures[i];
                add_texture_to_dom({
                    url: texture,
                    id: i + 1
                });
            }
        }

        function add_texture_to_dom(obj) {
            const container = document.getElementById('selected_tile_container');
            if (!container) return;

            const template = document.getElementById("tile_layer_template");
            if (!template) return;

            const compiled = Handlebars.compile(template.innerHTML);
            const out = compiled(obj);
            container.appendChild(out);
        }

        function add_tile_image(event) {
            if (!document.getElementById('add_tile_image').hasAttribute('data-file-target')) {
                alert('Please select a file')
                return;
            }
            const url = document.getElementById('add_tile_image').getAttribute('data-file-target');
            const image = document.createElement('img');

            image.onload = function() {
                const tile_map_width = image.width;
                const tile_map_height = image.height;
                const numTilesX = tile_map_width / (event.tsX || tile_map_width);
                const numTilesY = tile_map_height / (event.tsY || tile_map_height);

                if (numTilesX % 1 > 0 || numTilesY % 1 > 0) {
                    alert('Tile map width & height constraints do not match the input tile image width/height');
                    return;
                }

                const canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d');
                canvas.width = event.tsX || tile_map_width;
                canvas.height = event.tsY || tile_map_height;

                for (let x = 0; x < numTilesX; x++) {
                    for (let y = 0; y < numTilesY; y++) {
                        ctx.clearRect(0, 0, tile_map_width, tile_map_height);
                        ctx.drawImage(image, (x * (event.tsX || tile_map_width)) * -1, (y * (event.tsY || tile_map_height)) * -1, tile_map_width, tile_map_height);
                        var dataURL = canvas.toDataURL('image/png');
                        loadedTextures[loadedTextures.length] = dataURL;
                        add_texture_to_dom({
                            url: dataURL,
                            id: loadedTextures.length
                        });
                    }
                }
                document.getElementById('add_tile_image').removeAttribute('data-file-target');
                document.getElementById('image').value = '';
            }

            image.src = url;
        }


        var Base64 = {
            _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            encode: function(e) {
                var t = "";
                var n, r, i, s, o, u, a;
                var f = 0;
                e = Base64._utf8_encode(e);
                while (f < e.length) {
                    n = e.charCodeAt(f++);
                    r = e.charCodeAt(f++);
                    i = e.charCodeAt(f++);
                    s = n >> 2;
                    o = (n & 3) << 4 | r >> 4;
                    u = (r & 15) << 2 | i >> 6;
                    a = i & 63;
                    if (isNaN(r)) {
                        u = a = 64
                    } else if (isNaN(i)) {
                        a = 64
                    }
                    t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a)
                }
                return t
            },
            decode: function(e) {
                var t = "";
                var n, r, i;
                var s, o, u, a;
                var f = 0;
                e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                while (f < e.length) {
                    s = this._keyStr.indexOf(e.charAt(f++));
                    o = this._keyStr.indexOf(e.charAt(f++));
                    u = this._keyStr.indexOf(e.charAt(f++));
                    a = this._keyStr.indexOf(e.charAt(f++));
                    n = s << 2 | o >> 4;
                    r = (o & 15) << 4 | u >> 2;
                    i = (u & 3) << 6 | a;
                    t = t + String.fromCharCode(n);
                    if (u != 64) {
                        t = t + String.fromCharCode(r)
                    }
                    if (a != 64) {
                        t = t + String.fromCharCode(i)
                    }
                }
                t = Base64._utf8_decode(t);
                return t
            },
            _utf8_encode: function(e) {
                e = e.replace(/\r\n/g, "\n");
                var t = "";
                for (var n = 0; n < e.length; n++) {
                    var r = e.charCodeAt(n);
                    if (r < 128) {
                        t += String.fromCharCode(r)
                    } else if (r > 127 && r < 2048) {
                        t += String.fromCharCode(r >> 6 | 192);
                        t += String.fromCharCode(r & 63 | 128)
                    } else {
                        t += String.fromCharCode(r >> 12 | 224);
                        t += String.fromCharCode(r >> 6 & 63 | 128);
                        t += String.fromCharCode(r & 63 | 128)
                    }
                }
                return t
            },
            _utf8_decode: function(e) {
                var t = "";
                var n = 0;
                var r = c1 = c2 = 0;
                while (n < e.length) {
                    r = e.charCodeAt(n);
                    if (r < 128) {
                        t += String.fromCharCode(r);
                        n++
                    } else if (r > 191 && r < 224) {
                        c2 = e.charCodeAt(n + 1);
                        t += String.fromCharCode((r & 31) << 6 | c2 & 63);
                        n += 2
                    } else {
                        c2 = e.charCodeAt(n + 1);
                        c3 = e.charCodeAt(n + 2);
                        t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
                        n += 3
                    }
                }
                return t
            }
        }

        function save_map(event) {
            const object_to_serialize = {
                tWidth,
                tHeight
            }
            const imgs = {}
            const textures = document.querySelectorAll('#tiles_list li');
            for (let i = 0; i < textures.length; i++) {
                const li = textures[i];
                const id = li.getAttribute('data-id');
                const img = li.children[0];
                imgs[id] = img.src;
            }

            object_to_serialize.map = map;
            object_to_serialize.textures = imgs;
            const serializedObj = JSON.stringify(object_to_serialize);
            var encodedString = Base64.encode(serializedObj);
            var a = document.createElement("a");
            var file = new Blob([encodedString], {
                type: 'application/octet-stream'
            });
            a.href = URL.createObjectURL(file);
            a.download = 'map.tb';
            a.click();
        }


        function load_map(event) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.tb';
            input.onchange = function(event) {
                const reader = new FileReader();
                reader.onload = function() {
                    parse_map_json(reader.result)
                };
                reader.readAsText(event.target.files[0])
            }
            input.click();
        }


        function generate_map_data() {
            const map_data = document.getElementById('map_data');
            map_data.textContent = "";
            const imgs = {}
            const textures = document.querySelectorAll('#tiles_list li');
            for (let i = 0; i < textures.length; i++) {
                const li = textures[i];
                const id = li.getAttribute('data-id');
                const img = li.children[0];
                imgs[id] = img.src;
            }

            const map_to_json = [];

            for (let i = 0; i < map.length; i++) {
                map_to_json[i] = new Array(map[i].length).fill(0);
                for (let j = 0; j < map[i].length; j++) {
                    if (!map[i][j]) continue;
                    if (Array.isArray(map[i][j])) {
                        map_to_json[i][j] = [];
                        for (let k = 0; k < map[i][j].length; k++) {
                            map_to_json[i][j][k] = map[i][j][k].id;
                        }
                    } else {
                        map_to_json[i][j] = map[i][j].id;
                    }
                }
            }

            map_data.textContent += `const tile_sprites = ${JSON.stringify(imgs)};`
            map_data.textContent += `const map_data = ${JSON.stringify(map_to_json)};`;
        }


        function parse_map_json(json) {
            json = Base64.decode(json);
            try {
                json = JSON.parse(json);
            } catch (err) {
                alert('Error loading json file');
                return;
            }

            if (!json.map || !json.textures || json.tWidth == null || isNaN(json.tWidth) || json.tHeight == null ||
                isNaN(json.tHeight)) {
                alert('Invalid json file format');
                return;
            }

            const textures = json.textures;

            for (key in textures) {
                const li = document.createElement('li');
                li.setAttribute('data-id', key);
                const img = document.createElement('img');
                img.src = textures[key];
                img.setAttribute('data-id', key);
                li.appendChild(img);
                img.onclick = function(event) {
                    const eles = document.querySelectorAll('#tiles_list li img');
                    for (let i = 0; i < eles.length; i++) {
                        eles[i].style.border = 'none';
                    }
                    img.style.border = '2px solid red';
                    selectedTexture = {
                        id: key,
                        image: img
                    };
                }
                const tiles_list = document.getElementById('tiles_list');
                tiles_list.appendChild(li);
                textures[key] = img;
                currentTextureID = key;
            }

            const loaded_map = json.map;

            if (!Array.isArray(loaded_map)) {
                alert('Invalid json file format');
                return;
            }


            for (let i = 0; i < loaded_map.length; i++) {
                for (let j = 0; j < loaded_map[i].length; j++) {
                    if (loaded_map[i][j]) {
                        const arr = Array.isArray(loaded_map[i][j]) ? loaded_map[i][j] : [loaded_map[i][j]];
                        for (let k = 0; k < arr.length; k++) {
                            arr[k].image = textures[arr[k].id];
                        }
                    }
                }
            }

            map = loaded_map;
            tWidth = parseInt(json.tWidth);
            tHeight = parseInt(json.tHeight);
        }


        map_canvas.onmousemove = handle_canvas_mouse_move;
        map_canvas.onmouseup = handle_canvas_mouse_up;
        map_canvas.onmousedown = handle_canvas_mouse_down;
        document.getElementById('zoom_out').onclick = zoom_out;
        document.getElementById('zoom_in').onclick = zoom_in;
        window.addEventListener('keydown', handle_window_keydown);
        document.getElementById('load_map').onclick = load_map;
        document.getElementById('save_map').onclick = save_map;
        document.getElementById('generate_map_data').onclick = generate_map_data;
        requestAnimationFrame(update);
    </script>
    <noscript>
            <META HTTP-EQUIV="Refresh" CONTENT="2;URL=error.html">
    </noscript>
</body>

</html>